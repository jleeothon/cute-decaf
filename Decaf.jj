/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Decaf.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
               
                 
  DEBUG_TOKEN_MANAGER = true;
  DEBUG_PARSER = true;
  FORCE_LA_CHECK = true;
                       
}

PARSER_BEGIN(DecafParser)

import java.io.*;

public class DecafParser/*@bgen(jjtree)*/implements DecafParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTDecafParserState jjtree = new JJTDecafParserState();

/*@egen*/

  CuteSymbolTable currentScope;
  
  public static void main(String args []) throws ParseException
  {
    DecafParser parser = null;
    try
    {
      FileInputStream fis = new FileInputStream(args[0]);
      parser = new DecafParser(fis);
    }
    catch (IOException e)
    {
      System.err.println("Could not open file!");
    }
	catch (IndexOutOfBoundsException e)
	{
		System.err.println("Please specify a file!");
	}

	try
	{
	  DecafParser.program();
	  System.out.println("Yay!");
	}
	catch (Exception e)
	{
	    System.out.println("Oops. Exception.");
	    System.out.println(e.getMessage());
	    DecafParser.ReInit(System.in);
    }
    catch (Error e)
    {
	    System.out.println("Oops. Error.");
	    System.out.println(e.getMessage());
    }
  }
}

PARSER_END(DecafParser)


/*
 * Whitespaces
 */
SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "\f"
}

/*
 * Line comments
 */
SKIP :
{
	<
	  	"//"
	  	([
			"a"-"z", "A"-"Z", "0"-"9", "_",
			".", ",", ";", ":", "!", "?",
			"(", ")", "-", "+", "*", "/", "=", "<", ">",
			" "
		])*
	    ("\n" | "\r" | "\r\n")
	>
}

/*
 * Keywords
 */
TOKEN :
{
  < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < CALLOUT: "callout" >
| < CLASS: "class" >
| < CONTINUE: "continue" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FOR: "for" >
| < IF: "if" >
| < INT: "int" >
| < NEW: "new" >
| < NULL: "null" >
| < PROGRAM: "Program" >
| < RETURN: "return" >
| < THIS: "this" >
| < TRUE: "true" >
| < VOID: "void" >
| < WHILE: "while" >
}

/*
 * SYNTAX MARKERS
 */
TOKEN:
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACK: "[" >
| < RBRACK: "]" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < COMMA: "," >
| < SEMICOLON: ";" >
}

/*
 * Operators
 */
TOKEN:
{
  < UNARY_OP: "-" | "!" >
| < BIN_OP: < ARITH_OP > | < REL_OP > | < EQ_OP > | < COND_OP > >
| < ARITH_OP: "+" | "-" | "*" | "/" | "%" >
| < REL_OP: "<" | ">" | "<=" | "=>" >
| < EQ_OP: "==" | "!=" >
| < COND_OP: "&&" | "||" >
| < ASSIGN: "=" >
| < ASSIGN_SC: "=" | "+=" | "-=" >
}

/*
 * Identifier
 */
TOKEN:
{
  < ID: < ALPHA > (< ALPHA_NUM >)* >
}

/*
 * Literals
 */
TOKEN:
{
 < HEX_LITERAL: "0x" (< HEX_DIGIT >)+ >
| < DECIMAL_LITERAL: (["0"-"9"])+ >
| < CHAR: (["a"-"z", "A"-"Z", "_", "0"-"9"]
    | "\\t" | "\\n"
    | "\\\\" | "\\\"" | "\\'") >  
| < ALPHA_NUM: < ALPHA > | ["0"-"9"] >
| < ALPHA: ["a"-"z","A"-"Z","_"] >
| < HEX_DIGIT: ["0"-"9", "a"-"f", "A"-"F"] >
| < BOOL_LITERAL: "true" | "false" >
| < CHAR_LITERAL: "'" < CHAR > "'" >
| < STRING_LITERAL: "\"" (< CHAR >)* "\"" >
}

// ------------ PARSER ------------

void program():
{/*@bgen(jjtree) program */
  Cuteprogram jjtn000 = new Cuteprogram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) program */
  try {
/*@egen*/
  < CLASS >
  < PROGRAM >
  < LBRACE >
  (LOOKAHEAD(3) fieldDecl())*
  (methodDecl())*
  < RBRACE >
  <EOF>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void fieldDeclVar():
{/*@bgen(jjtree) fieldDeclVar */
  CutefieldDeclVar jjtn000 = new CutefieldDeclVar(JJTFIELDDECLVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) fieldDeclVar */
  try {
/*@egen*/
  < ID >
  (
    < LBRACK >
    intLiteral()
    < RBRACK >
  )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void fieldDecl():
{/*@bgen(jjtree) fieldDecl */
  CutefieldDecl jjtn000 = new CutefieldDecl(JJTFIELDDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) fieldDecl */
  try {
/*@egen*/
  type()
   fieldDeclVar()
  (
    < COMMA >
     fieldDeclVar()
  )*
   <SEMICOLON>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void methodDeclVar():
{/*@bgen(jjtree) methodDeclVar */
  CutemethodDeclVar jjtn000 = new CutemethodDeclVar(JJTMETHODDECLVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) methodDeclVar */
        try {
/*@egen*/
	type() < ID >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void methodDecl():
{/*@bgen(jjtree) methodDecl */
  CutemethodDecl jjtn000 = new CutemethodDecl(JJTMETHODDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) methodDecl */
  try {
/*@egen*/
  (type() | < VOID >)
  < ID >
  < LPAREN >
  (
    methodDeclVar()
    (
      < COMMA >
      methodDeclVar()
    )*
  )?
  < RPAREN >
  block()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void block():
{/*@bgen(jjtree) block */
  Cuteblock jjtn000 = new Cuteblock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) block */
  try {
/*@egen*/
  < LBRACE >
  (varDecl())*
  (statement())*
  < RBRACE >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void varDecl():
{/*@bgen(jjtree) varDecl */
  CutevarDecl jjtn000 = new CutevarDecl(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) varDecl */
  try {
/*@egen*/
  type()
  < ID >
  (< COMMA > < ID >)*
  < SEMICOLON >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void type():
{/*@bgen(jjtree) type */
  Cutetype jjtn000 = new Cutetype(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  
}
{/*@bgen(jjtree) type */
        try {
/*@egen*/
	< INT > | < BOOLEAN >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ifStatement():
{/*@bgen(jjtree) ifStatement */
  CuteifStatement jjtn000 = new CuteifStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) ifStatement */
  try {
/*@egen*/
  < IF > < LPAREN > expression() < RPAREN > block() (< ELSE > block())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void forStatement():
{/*@bgen(jjtree) forStatement */
  CuteforStatement jjtn000 = new CuteforStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) forStatement */
  try {
/*@egen*/
  < FOR > < ID > < ASSIGN > expression() < COMMA > expression() block()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statement():
{/*@bgen(jjtree) statement */
  Cutestatement jjtn000 = new Cutestatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) statement */
  try {
/*@egen*/
  LOOKAHEAD(3)
  assignment() < SEMICOLON >
| methodCall() < SEMICOLON >
| ifStatement()
| forStatement()
| < RETURN > (LOOKAHEAD(2) expression())? < SEMICOLON >
| < BREAK > <SEMICOLON >
| < CONTINUE > < SEMICOLON >
| block()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void assignment():
{/*@bgen(jjtree) assignment */
  Cuteassignment jjtn000 = new Cuteassignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  
}
{/*@bgen(jjtree) assignment */
  try {
/*@egen*/
  location() (< ASSIGN_SC > | < ASSIGN >) expression() < SEMICOLON >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void location():
{/*@bgen(jjtree) location */
  Cutelocation jjtn000 = new Cutelocation(JJTLOCATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) location */
  try {
/*@egen*/
  < ID > (< LBRACK > expression() < RBRACK >)?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void methodCall():
{/*@bgen(jjtree) methodCall */
  CutemethodCall jjtn000 = new CutemethodCall(JJTMETHODCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) methodCall */
  try {
/*@egen*/
  LOOKAHEAD(2)
  methodName() < LPAREN > (expression() (< COMMA > expression())*)? < RPAREN >
| < CALLOUT > < LPAREN > < STRING_LITERAL > (< COMMA > calloutArg())* < RPAREN >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void methodName():
{/*@bgen(jjtree) methodName */
  CutemethodName jjtn000 = new CutemethodName(JJTMETHODNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/

}
{/*@bgen(jjtree) methodName */
  try {
/*@egen*/
  < ID >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void expression():
{/*@bgen(jjtree) expression */
  Cuteexpression jjtn000 = new Cuteexpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) expression */
  try {
/*@egen*/
  expression1() (LOOKAHEAD(< BIN_OP >) < BIN_OP > expression1())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void expression1():
{/*@bgen(jjtree) expression1 */
  Cuteexpression1 jjtn000 = new Cuteexpression1(JJTEXPRESSION1);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) expression1 */
  try {
/*@egen*/
  LOOKAHEAD(methodCall()) methodCall()
  location()
| LOOKAHEAD(3) literal()
| < UNARY_OP > expression()
| < LPAREN > expression() < RPAREN >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void calloutArg():
{/*@bgen(jjtree) calloutArg */
  CutecalloutArg jjtn000 = new CutecalloutArg(JJTCALLOUTARG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) calloutArg */
  try {
/*@egen*/
  expression() | < STRING_LITERAL >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void literal():
{/*@bgen(jjtree) literal */
  Cuteliteral jjtn000 = new Cuteliteral(JJTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) literal */
  try {
/*@egen*/
  intLiteral() | LOOKAHEAD(3) < CHAR_LITERAL > | < BOOL_LITERAL >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void intLiteral():
{/*@bgen(jjtree) intLiteral */
  CuteintLiteral jjtn000 = new CuteintLiteral(JJTINTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) intLiteral */
  try {
/*@egen*/
  < DECIMAL_LITERAL > | < HEX_LITERAL >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}